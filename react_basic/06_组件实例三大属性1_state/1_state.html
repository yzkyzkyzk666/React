<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>state</title>
</head>
<body>
	<!-- 准备好一个“容器” -->
	<div id="test"></div>
	
	<!-- 引入react核心库 -->
	<script type="text/javascript" src="../js/react.development.js"></script>
	<!-- 引入react-dom，用于支持react操作DOM -->
	<script type="text/javascript" src="../js/react-dom.development.js"></script>
	<!-- 引入babel，用于将jsx转为js -->
	<script type="text/javascript" src="../js/babel.min.js"></script>

	<script type="text/babel">
		//1.创建组件
		class Weather extends React.Component{
			
			//构造器调用几次？ ———— 1次
			constructor(props){
				console.log('constructor');
				super(props)/*如果A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的。*/
				//初始化状态
				this.state = {isHot:false,wind:'微风'}
				//解决changeWeather中this指向问题
				this.changeWeather = this.changeWeather.bind(this)//bind一可以生成新的函数，二可以改变this指向
				//该函数里的this已经成功地变为了Weather的实例对象，然后把右边的函数放到左边实例的自身，然后给函数起了个名字changeWeather
				//把原型上有的changeWeather产生一个新的changeWeather挂在实例自身
			}

			//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
			render(){
				console.log('render');
				//读取状态
				const {isHot,wind} = this.state
				return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>/*三元表达式*/
			}

			//changeWeather调用几次？ ———— 点几次调几次
			changeWeather(){/*函数体里可以写任意的代码，但是类里不行，要把function删掉*/
				//changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用
				//通过Weather实例调用changeWeather时，changeWeather中的this就是Weather的实例对象
				//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用（和render和构造器里通过实例对象调用不一样）
				//类中所有你定义的方法，它在局部都开启了严格模式，类自动开的 和babel没关系
				//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined(严格模式里的自定义函数this不指向window)
				
				console.log('changeWeather');
				//获取原来的isHot值
				const isHot = this.state.isHot
				//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
				this.setState({isHot:!isHot})
				console.log(this);

				//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
				//this.state.isHot = !isHot //这是错误的写法
			}
		}
		//2.渲染组件到页面
		ReactDOM.render(<Weather/>,document.getElementById('test'))
				
	</script>
</body>
</html>